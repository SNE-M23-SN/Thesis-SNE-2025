-- Enable pg_cron extension
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Create the chat_messages table as per the JPA entity
CREATE TABLE IF NOT EXISTS chat_messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    conversation_id VARCHAR(255) NOT NULL,
    job_name VARCHAR(255) NOT NULL,
    build_number INTEGER NOT NULL,
    message_type VARCHAR(255) NOT NULL,
    content JSONB NOT NULL,
    timestamp TIMESTAMP(6) WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP(6) WITH TIME ZONE NOT NULL,
    metadata VARCHAR(255)
);


-- Table to store precomputed total job counts
CREATE TABLE IF NOT EXISTS job_counts (
    id BIGSERIAL PRIMARY KEY,
    time_boundary VARCHAR(50) NOT NULL, -- '7_days', '14_days', etc.
    total_jobs INTEGER NOT NULL,
    computed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(time_boundary)
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_job_name_timestamp_message_type
ON chat_messages (job_name, timestamp, message_type)
WHERE (message_type = 'USER' AND content->>'type' = 'build_log_data')
   OR message_type = 'ASSISTANT';

CREATE OR REPLACE FUNCTION trigger_compute_total_jobs() RETURNS TRIGGER AS $$
DECLARE
    last_computed_at TIMESTAMPTZ;
    has_new_job BOOLEAN := FALSE;
BEGIN
    -- Get last computed timestamp
    SELECT MAX(computed_at) INTO last_computed_at FROM job_counts;
    
    -- If no previous computation, always compute
    IF last_computed_at IS NULL THEN
        PERFORM compute_total_jobs();
        RETURN NULL;
    END IF;
    
    -- Check if any new job name didn't exist before last computation
    SELECT EXISTS (
        SELECT 1
        FROM (
            SELECT DISTINCT job_name
            FROM new_rows
            WHERE (message_type = 'USER' AND content->>'type' = 'build_log_data')
               OR message_type = 'ASSISTANT'
        ) nr
        WHERE NOT EXISTS (
            SELECT 1
            FROM chat_messages cm
            WHERE cm.job_name = nr.job_name
              AND cm.id NOT IN (SELECT id FROM new_rows)
              AND cm.timestamp < last_computed_at
              AND ((cm.message_type = 'USER' AND cm.content->>'type' = 'build_log_data')
                   OR cm.message_type = 'ASSISTANT')
        )
    ) INTO has_new_job;
    
    IF has_new_job THEN
        PERFORM compute_total_jobs();
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION compute_total_jobs() RETURNS VOID AS $$
DECLARE
    boundaries TEXT[] := ARRAY['7_days', '14_days', '30_days', '60_days', '180_days', 'all_time'];
    boundary TEXT;
    start_time TIMESTAMPTZ;
    job_count INTEGER;
BEGIN
    FOREACH boundary IN ARRAY boundaries
    LOOP
        CASE boundary
            WHEN '7_days'   THEN start_time := NOW() - INTERVAL '7 days';
            WHEN '14_days'  THEN start_time := NOW() - INTERVAL '14 days';
            WHEN '30_days'  THEN start_time := NOW() - INTERVAL '30 days';
            WHEN '60_days'  THEN start_time := NOW() - INTERVAL '60 days';
            WHEN '180_days' THEN start_time := NOW() - INTERVAL '180 days';
            WHEN 'all_time' THEN start_time := NULL;
            ELSE RAISE EXCEPTION 'Unknown time boundary: %', boundary;
        END CASE;

        IF start_time IS NULL THEN
            SELECT COUNT(DISTINCT job_name) INTO job_count 
            FROM chat_messages
            WHERE (message_type = 'USER' AND content->>'type' = 'build_log_data')
               OR message_type = 'ASSISTANT';
        ELSE
            SELECT COUNT(DISTINCT job_name) INTO job_count 
            FROM chat_messages
            WHERE timestamp >= start_time
              AND ((message_type = 'USER' AND content->>'type' = 'build_log_data')
                   OR message_type = 'ASSISTANT');
        END IF;

        INSERT INTO job_counts (time_boundary, total_jobs, computed_at)
        VALUES (boundary, job_count, NOW())
        ON CONFLICT (time_boundary) DO UPDATE
        SET total_jobs = EXCLUDED.total_jobs,
            computed_at = EXCLUDED.computed_at;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_compute_jobs ON chat_messages;

CREATE TRIGGER trg_compute_jobs
AFTER INSERT ON chat_messages
REFERENCING NEW TABLE AS new_rows
FOR EACH STATEMENT
EXECUTE FUNCTION trigger_compute_total_jobs();

CREATE TABLE active_build_counts (
    id BIGSERIAL PRIMARY KEY,
    job_filter VARCHAR(255) NOT NULL,
    active_builds INTEGER NOT NULL,
    computed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    UNIQUE(job_filter)
);
CREATE INDEX IF NOT EXISTS idx_chat_messages_content_type_btree ON chat_messages ((content->>'type'));
CREATE INDEX IF NOT EXISTS idx_chat_messages_job_build_timestamp ON chat_messages (job_name, build_number, timestamp);


CREATE OR REPLACE FUNCTION compute_active_builds() RETURNS VOID AS $$
DECLARE
    job_rec RECORD;
    active_count INTEGER;
    total_active_count INTEGER := 0;
    freshness_interval INTERVAL := INTERVAL '3 minutes';
    result_finished_statuses TEXT[] := ARRAY['SUCCESS', 'FAILURE', 'ABORTED'];
BEGIN
    -- Clear existing counts
    DELETE FROM active_build_counts;

    -- Count for each job_name (last 5 builds per job)
    FOR job_rec IN
        SELECT DISTINCT job_name
        FROM chat_messages
        WHERE content->>'type' = 'build_log_data'
    LOOP
        WITH last_five_builds AS (
            SELECT 
                build_number,
                MAX(timestamp) AS last_timestamp,
                (SELECT COUNT(*)
                 FROM chat_messages sub
                 WHERE sub.job_name = job_rec.job_name
                   AND sub.build_number = cm.build_number
                   AND sub.content->>'type' = 'build_log_data') AS log_count,
                (SELECT content->'data'->>'result'
                 FROM chat_messages sub
                 WHERE sub.job_name = job_rec.job_name
                   AND sub.build_number = cm.build_number
                   AND sub.content->>'type' = 'build_log_data'
                 ORDER BY sub.timestamp DESC
                 LIMIT 1) AS last_result
            FROM chat_messages cm
            WHERE cm.job_name = job_rec.job_name
              AND cm.content->>'type' = 'build_log_data'
            GROUP BY build_number
            ORDER BY MAX(timestamp) DESC
            LIMIT 5
        )
        SELECT COUNT(*)
        INTO active_count
        FROM last_five_builds
        WHERE
       (log_count < 2 AND (last_result IS NULL OR last_result NOT IN (SELECT UNNEST(result_finished_statuses))))
        OR (
            log_count = 2
            AND last_result NOT IN (SELECT UNNEST(result_finished_statuses))
            AND last_timestamp >= NOW() - freshness_interval
        );
        -- Accumulate total active builds for 'all'
        total_active_count := total_active_count + active_count;
        -- Insert per-job count
        INSERT INTO active_build_counts (job_filter, active_builds, computed_at)
        VALUES (job_rec.job_name, active_count, NOW())
        ON CONFLICT (job_filter) DO UPDATE
        SET active_builds = EXCLUDED.active_builds,
            computed_at = EXCLUDED.computed_at;
    END LOOP;

    -- Insert total active builds for 'all'
    INSERT INTO active_build_counts (job_filter, active_builds, computed_at)
    VALUES ('all', total_active_count, NOW())
    ON CONFLICT (job_filter) DO UPDATE
    SET active_builds = EXCLUDED.active_builds,
        computed_at = EXCLUDED.computed_at;

    RAISE NOTICE 'Computed active builds for all and specific jobs at %', NOW();
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION trigger_compute_active_builds() RETURNS trigger AS $$
BEGIN
    -- Only call compute_active_builds if inserted row has content->>'type' = 'build_log_data'
    IF NEW.content->>'type' = 'build_log_data' THEN
        PERFORM compute_active_builds();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


DROP TRIGGER IF EXISTS trg_compute_active_builds ON chat_messages;

CREATE TRIGGER trg_compute_active_builds
AFTER INSERT ON chat_messages
FOR EACH ROW
EXECUTE FUNCTION trigger_compute_active_builds();



CREATE EXTENSION IF NOT EXISTS pg_cron;
SELECT cron.schedule(
    'Compute active builds',
    '*/2 * * * *',
    $$SELECT compute_active_builds()$$
);


CREATE TABLE IF NOT EXISTS security_anomaly_counts (
    id BIGSERIAL PRIMARY KEY,
    job_filter TEXT NOT NULL,
    anomaly_count INTEGER NOT NULL,
    time_range TEXT NOT NULL,
    computed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    UNIQUE(job_filter, time_range)
);

CREATE OR REPLACE FUNCTION compute_security_anomalies() RETURNS VOID AS $$
DECLARE
    job_rec RECORD;
    time_range_rec TEXT;
    total_anomalies INTEGER;
    anomaly_count INTEGER;
    start_time TIMESTAMP WITH TIME ZONE;
    time_ranges TEXT[] := ARRAY['7 days', '14 days', '30 days', '60 days', '180 days', 'all time'];
BEGIN
    -- Clear all rows for fresh data
    DELETE FROM security_anomaly_counts;

    -- Loop through each time range
    FOREACH time_range_rec IN ARRAY time_ranges
    LOOP
        -- Set start_time based on time range
        start_time := CASE time_range_rec
            WHEN '7 days' THEN NOW() - INTERVAL '7 days'
            WHEN '14 days' THEN NOW() - INTERVAL '14 days'
            WHEN '30 days' THEN NOW() - INTERVAL '30 days'
            WHEN '60 days' THEN NOW() - INTERVAL '60 days'
            WHEN '180 days' THEN NOW() - INTERVAL '180 days'
            ELSE NULL
        END;

        -- Initialize total anomalies for 'all'
        total_anomalies := 0;

        -- Loop through all jobs with ASSISTANT rows (any time)
        FOR job_rec IN
            SELECT DISTINCT job_name
            FROM chat_messages
            WHERE message_type = 'ASSISTANT'
        LOOP
            -- Count anomalies for this job and time range
            SELECT COALESCE(SUM(jsonb_array_length(content->'anomalies')), 0)
            INTO anomaly_count
            FROM (
                SELECT DISTINCT ON (job_name, build_number)
                    job_name,
                    build_number,
                    content
                FROM chat_messages
                WHERE message_type = 'ASSISTANT'
                  AND job_name = job_rec.job_name
                  AND (start_time IS NULL OR timestamp >= start_time)
                ORDER BY job_name, build_number, timestamp DESC
            ) latest_assistant
            WHERE content ? 'anomalies';

            -- Add to total for 'all'
            total_anomalies := total_anomalies + anomaly_count;

            -- Insert or update per-job count
            INSERT INTO security_anomaly_counts (job_filter, anomaly_count, time_range, computed_at)
            VALUES (job_rec.job_name, anomaly_count, time_range_rec, NOW() AT TIME ZONE 'Asia/Kolkata')
            ON CONFLICT (job_filter, time_range) DO UPDATE
            SET anomaly_count = EXCLUDED.anomaly_count,
                computed_at = EXCLUDED.computed_at;
        END LOOP;

        -- Insert or update total for 'all'
        INSERT INTO security_anomaly_counts (job_filter, anomaly_count, time_range, computed_at)
        VALUES ('all', total_anomalies, time_range_rec, NOW() AT TIME ZONE 'Asia/Kolkata')
        ON CONFLICT (job_filter, time_range) DO UPDATE
        SET anomaly_count = EXCLUDED.anomaly_count,
            computed_at = EXCLUDED.computed_at;
    END LOOP;

    RAISE NOTICE 'Computed security anomalies at %', NOW();
END;
$$ LANGUAGE plpgsql;


CREATE INDEX IF NOT EXISTS idx_chat_messages_message_type_timestamp 
ON chat_messages (message_type, timestamp DESC);

CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_job_build_time 
ON chat_messages (message_type, job_name, build_number, timestamp DESC) 
WHERE message_type = 'ASSISTANT';

CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_content_gin 
ON chat_messages USING GIN (content) 
WHERE message_type = 'ASSISTANT';



CREATE OR REPLACE FUNCTION trigger_compute_security_anomalies() RETURNS TRIGGER AS $$
BEGIN
    PERFORM compute_security_anomalies();
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_compute_security_anomalies
AFTER INSERT ON chat_messages
FOR EACH ROW
WHEN (NEW.message_type = 'ASSISTANT')
EXECUTE FUNCTION trigger_compute_security_anomalies();


DROP TABLE IF EXISTS recent_job_builds;
CREATE TABLE recent_job_builds (
    job_name TEXT NOT NULL,
    build_id INTEGER NOT NULL,
    health_status TEXT,
    anomaly_count INTEGER,
    time_ago TEXT,
    raw_timestamp TIMESTAMP WITH TIME ZONE,
    computed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    original_job_name TEXT NOT NULL,
    PRIMARY KEY (job_name, build_id, original_job_name)
);


CREATE OR REPLACE FUNCTION compute_recent_job_builds() 
RETURNS VOID AS $$
BEGIN
    TRUNCATE recent_job_builds;

    WITH ranked_builds AS (
        SELECT DISTINCT ON (cm.job_name, cm.build_number)
            cm.job_name,
            cm.build_number AS build_id,
            CASE 
                WHEN cm.content->'buildMetadata'->>'status' = 'SUCCESS' THEN 'Healthy'
                ELSE 'Unhealthy'
            END AS health_status,
            COALESCE(jsonb_array_length(cm.content->'anomalies'), 0) AS anomaly_count,
            cm.timestamp AS raw_timestamp,
            ROW_NUMBER() OVER (PARTITION BY cm.job_name ORDER BY cm.timestamp DESC) AS rn
        FROM chat_messages cm
        WHERE cm.message_type = 'ASSISTANT'
          AND cm.content ? 'anomalies'
          AND jsonb_array_length(cm.content->'anomalies') > 0
    ),
    formatted_builds AS (
        SELECT 
            rb.job_name,
            rb.build_id,
            rb.health_status,
            rb.anomaly_count,
            CASE
                WHEN EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) < 60 THEN 
                    (EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)))::INTEGER || ' seconds ago'
                WHEN EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) < 3600 THEN 
                    FLOOR(EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) / 60)::INTEGER || ' minutes ago'
                WHEN EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) < 86400 THEN 
                    FLOOR(EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) / 3600)::INTEGER || ' hours ago'
                WHEN EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) < 2592000 THEN 
                    FLOOR(EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) / 86400)::INTEGER || ' days ago'
                WHEN EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) < 31536000 THEN 
                    FLOOR(EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) / 2592000)::INTEGER || ' months ago'
                ELSE
                    FLOOR(EXTRACT(EPOCH FROM (NOW() - rb.raw_timestamp)) / 31536000)::INTEGER || ' years ago'
            END AS time_ago,
            rb.raw_timestamp
        FROM ranked_builds rb
        WHERE rb.rn <= 3
    ),
    per_job_insert AS (
        INSERT INTO recent_job_builds (
            job_name, build_id, health_status, anomaly_count, time_ago, raw_timestamp, original_job_name
        )
        SELECT 
            job_name, 
            build_id, 
            health_status, 
            anomaly_count, 
            time_ago, 
            raw_timestamp,
            job_name
        FROM formatted_builds
        RETURNING *
    ),
    all_formatted AS (
        SELECT DISTINCT ON (build_id)
            'all' AS job_name,
            build_id,
            MAX(health_status) AS health_status,  -- Use latest status
            MAX(anomaly_count) AS anomaly_count,
            MAX(time_ago) AS time_ago,
            MAX(raw_timestamp) AS raw_timestamp,
            original_job_name
        FROM per_job_insert
        GROUP BY build_id, original_job_name
        ORDER BY build_id, raw_timestamp DESC
        LIMIT 3
    )
    INSERT INTO recent_job_builds (
        job_name, build_id, health_status, anomaly_count, time_ago, raw_timestamp, original_job_name
    )
    SELECT * FROM all_formatted;

    RAISE NOTICE 'Computed recent job builds at %', NOW();
END;
$$ LANGUAGE plpgsql;


-- On chat_messages
CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_job_build_time
ON chat_messages (message_type, job_name, build_number, "timestamp" DESC)
WHERE message_type = 'ASSISTANT';

CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_content_gin
ON chat_messages USING GIN (content)
WHERE message_type = 'ASSISTANT';

-- On recent_job_builds
CREATE INDEX IF NOT EXISTS idx_recent_job_builds_timestamp ON recent_job_builds (raw_timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_recent_job_builds_original_job ON recent_job_builds (original_job_name, raw_timestamp DESC);


CREATE INDEX IF NOT EXISTS idx_recent_job_builds_timestamp ON recent_job_builds (raw_timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_recent_job_builds_original_job ON recent_job_builds (original_job_name, raw_timestamp DESC);



CREATE OR REPLACE FUNCTION trigger_compute_recent_job_builds()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM compute_recent_job_builds();
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;


-- Drop the existing trigger if it exists
DROP TRIGGER IF EXISTS trig_compute_recent_job_builds ON chat_messages;

-- Create a statement-level trigger
CREATE TRIGGER trig_compute_recent_job_builds
AFTER INSERT OR UPDATE OF message_type, content ON chat_messages
FOR EACH STATEMENT
EXECUTE FUNCTION trigger_compute_recent_job_builds();


CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_job_build
ON chat_messages (message_type, conversation_id, build_number)
WHERE message_type = 'ASSISTANT';


CREATE INDEX IF NOT EXISTS idx_chat_messages_content_anomalies ON chat_messages 
    USING gin ((content -> 'anomalies'));


CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_job_build
ON chat_messages (message_type, conversation_id, build_number)
WHERE message_type = 'ASSISTANT';

CREATE INDEX IF NOT EXISTS idx_chat_messages_content_anomalies ON chat_messages 
    USING gin ((content -> 'anomalies'));


CREATE INDEX IF NOT EXISTS idx_chat_messages_assistant_conversation_build ON chat_messages
(message_type, conversation_id, build_number)
WHERE message_type = 'ASSISTANT';

CREATE TABLE build_anomaly_summary (
    id BIGSERIAL PRIMARY KEY,
    conversation_id VARCHAR(255) NOT NULL,
    build_number INTEGER NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    total_anomalies INTEGER NOT NULL,
    severity_counts JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index for querying latest builds
CREATE INDEX IF NOT EXISTS idx_build_anomaly_summary_latest ON build_anomaly_summary
(conversation_id, timestamp DESC, build_number DESC);

CREATE INDEX IF NOT EXISTS idx_chat_messages_conversation_id ON chat_messages (conversation_id);
CREATE INDEX IF NOT EXISTS idx_chat_messages_message_type ON chat_messages (message_type);
CREATE INDEX IF NOT EXISTS idx_chat_messages_conversation_build ON chat_messages (conversation_id, build_number);
-- Optional:
CREATE INDEX IF NOT EXISTS idx_chat_messages_timestamp ON chat_messages (timestamp DESC);

CREATE OR REPLACE FUNCTION update_build_anomaly_summary()
RETURNS TRIGGER AS $$
BEGIN
    -- Delete existing entry for the same conversation_id and build_number
    DELETE FROM build_anomaly_summary
    WHERE conversation_id = NEW.conversation_id
      AND build_number = NEW.build_number;

    -- Insert new summary if message_type is ASSISTANT
    IF NEW.message_type = 'ASSISTANT' THEN
        INSERT INTO build_anomaly_summary (conversation_id, build_number, timestamp, total_anomalies, severity_counts)
        SELECT
            NEW.conversation_id,
            NEW.build_number,
            NEW.timestamp,
            COALESCE(jsonb_array_length(NEW.content->'anomalies'), 0) AS total_anomalies,
            COALESCE(jsonb_object_agg(severity, count), '{}'::jsonb) AS severity_counts
        FROM (
            SELECT
                (anomaly->>'severity')::text AS severity,
                COUNT(*) AS count
            FROM jsonb_array_elements(COALESCE(NEW.content->'anomalies', '[]'::jsonb)) AS anomaly
            GROUP BY (anomaly->>'severity')::text
        ) t;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_build_anomaly_summary ON chat_messages;

CREATE TRIGGER trigger_update_build_anomaly_summary
    AFTER INSERT OR UPDATE OF content, build_number ON chat_messages
    FOR EACH ROW
    WHEN (NEW.message_type = 'ASSISTANT')
    EXECUTE FUNCTION update_build_anomaly_summary();

CREATE INDEX IF NOT EXISTS idx_chat_messages_conv_msg_timestamp_partial ON chat_messages (conversation_id, message_type, timestamp DESC)
WHERE message_type = 'ASSISTANT';

-- Primary index for both queries (covers findLatestInsightsByConversation and partial use for findLatestInsights)
CREATE INDEX IF NOT EXISTS idx_chat_messages_conv_msg_timestamp ON chat_messages (conversation_id, message_type, timestamp DESC);

-- Specific index for findLatestInsights (includes build_number)
CREATE INDEX IF NOT EXISTS idx_chat_messages_conv_build_msg_timestamp ON chat_messages (conversation_id, build_number, message_type, timestamp DESC);


-- Keep existing
CREATE INDEX IF NOT EXISTS idx_chat_messages_content_path
ON chat_messages USING GIN (content jsonb_path_ops);

-- Add recommended
CREATE INDEX IF NOT EXISTS idx_chat_messages_conversation_build_timestamp
ON chat_messages (conversation_id, build_number, timestamp DESC);

CREATE INDEX IF NOT EXISTS idx_chat_messages_computed_build_status
ON chat_messages (
    conversation_id,
    build_number,
    timestamp DESC,
    COALESCE(
        NULLIF(content -> 'buildMetadata' ->> 'status', ''),
        NULLIF(content -> 'data' -> 'build_info' ->> 'result', ''),
        'UNKNOWN'
    )
);

CREATE INDEX IF NOT EXISTS idx_build_anomaly_summary_conversation_build
ON build_anomaly_summary (conversation_id, build_number);

CREATE INDEX IF NOT EXISTS idx_active_build_counts_job_filter
ON active_build_counts (job_filter);

-- Optional covering index (add if needed)
CREATE INDEX IF NOT EXISTS idx_chat_messages_status_filtered
ON chat_messages (conversation_id, build_number, timestamp DESC)
WHERE COALESCE(
    NULLIF(content -> 'buildMetadata' ->> 'status', ''),
    NULLIF(content -> 'data' -> 'build_info' ->> 'result', ''),
    'UNKNOWN'
) != 'UNKNOWN';

CREATE INDEX IF NOT EXISTS idx_chat_messages_job_name ON chat_messages (job_name);

CREATE INDEX IF NOT EXISTS idx_chat_messages_user_content_gin 
ON chat_messages USING GIN (content) 
WHERE message_type = 'USER';

CREATE INDEX IF NOT EXISTS idx_chat_messages_user_job_build_timestamp 
ON chat_messages (message_type, conversation_id, build_number, timestamp) 
WHERE message_type = 'USER';

